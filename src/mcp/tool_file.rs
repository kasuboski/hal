//! File operation tools for RMCP server using attribute macros
//!
//! This module contains tools for file operations using the new RMCP attribute macro pattern.

use serde_json::json;
use std::path::PathBuf;

use rmcp::{
    Error,
    handler::server::tool::ToolBox,
    model::{CallToolResult, Content},
    schemars, tool,
};

use crate::mcp::file_utils;
use crate::mcp::permissions::PermissionsRef;

/// File tools handler implementing operations on files and directories
#[derive(Clone)]
#[allow(dead_code)] // Field is used indirectly by RMCP macros
pub struct FileTools {
    /// Permissions manager
    permissions: PermissionsRef,
}

#[tool(tool_box)]
impl FileTools {
    /// Create a new FileTools instance with the necessary dependencies
    pub fn new(permissions: PermissionsRef) -> Self {
        Self { permissions }
    }

    pub fn get_tool_box() -> &'static ToolBox<Self> {
        // Calls the associated function generated by #[tool(tool_box)]
        Self::tool_box()
    }

    /// Show file contents with optional line range
    #[tool(
        description = "View file contents with optional line range - returns text content. Requires prior read permission via request_permission tool. Specify start_line and end_line to view specific portions of larger files."
    )]
    async fn show_file(
        &self,
        #[tool(param)]
        #[schemars(description = "Path to the file")]
        path: String,

        #[tool(param)]
        #[schemars(description = "Starting line number (1-based, optional)")]
        start_line: Option<i32>,

        #[tool(param)]
        #[schemars(description = "Ending line number (inclusive, optional)")]
        end_line: Option<i32>,
    ) -> Result<CallToolResult, Error> {
        let path_buf = PathBuf::from(&path);

        // Check read permission for the file's directory
        let perms = self.permissions.lock().await;
        if !perms.can_read(&path_buf) {
            return Err(Error::invalid_request(
                format!("No read permission for file: {}", path_buf.display()),
                None,
            ));
        }
        drop(perms);

        // Validate line range parameters if provided
        if let Some(start) = start_line {
            if start <= 0 {
                return Err(Error::invalid_request(
                    "start_line must be a positive integer (1-based indexing)",
                    None,
                ));
            }
        }

        if let Some(start) = start_line {
            if let Some(end) = end_line {
                if end < start {
                    return Err(Error::invalid_request(
                        format!(
                            "end_line ({}) cannot be less than start_line ({})",
                            end, start
                        ),
                        None,
                    ));
                }
            }
        }

        let start_line = start_line.map(|i| i as usize);
        let end_line = end_line.map(|i| i as usize);

        // Read file contents with optional line range
        match file_utils::show_file(&path_buf, &self.permissions, start_line, end_line).await {
            Ok(content) => {
                let line_count = content.lines().count();
                let result_json = json!({
                    "success": true,
                    "content": content,
                    "path": path,
                    "lines": {
                        "start": start_line.unwrap_or(1),
                        "end": end_line,
                        "total": line_count,
                        "selected": line_count
                    }
                });

                Ok(CallToolResult::success(vec![Content::text(
                    serde_json::to_string(&result_json).unwrap(),
                )]))
            }
            Err(e) => Err(Error::invalid_request(
                format!("Error reading file {}: {}", path_buf.display(), e),
                None,
            )),
        }
    }

    /// Search for patterns in a file
    #[tool(
        description = "Search for text patterns or regex in files - returns matching lines with line numbers. Set is_regex=true for regex mode. Requires read permission. Returns both line numbers and matching content. Use search results to identify specific code sections for further operations."
    )]
    async fn search_in_file(
        &self,
        #[tool(param)]
        #[schemars(description = "Path to the file")]
        path: String,

        #[tool(param)]
        #[schemars(description = "Search pattern (string or regex)")]
        pattern: String,

        #[tool(param)]
        #[schemars(description = "Whether to treat pattern as regex (default: false)")]
        is_regex: Option<bool>,
    ) -> Result<CallToolResult, Error> {
        let path_buf = PathBuf::from(&path);
        let use_regex = is_regex.unwrap_or(false);

        // Check read permission for the file's directory
        let perms = self.permissions.lock().await;
        if !perms.can_read(&path_buf) {
            return Err(Error::invalid_request(
                format!("No read permission for file: {}", path_buf.display()),
                None,
            ));
        }
        drop(perms);

        // Validate regex pattern if regex mode is enabled
        if use_regex {
            match regex::Regex::new(&pattern) {
                Ok(_) => {} // Valid regex
                Err(e) => {
                    return Err(Error::invalid_request(
                        format!("Invalid regex pattern '{}': {}", pattern, e),
                        None,
                    ));
                }
            }
        }

        // Search in the file
        match file_utils::search_in_file(&path_buf, &self.permissions, &pattern, use_regex).await {
            Ok(matches) => {
                // Transform matches into more structured format with line numbers and content
                let formatted_matches: Vec<serde_json::Value> = matches
                    .iter()
                    .map(|(line_num, content)| {
                        json!({
                            "line": line_num,
                            "content": content
                        })
                    })
                    .collect();

                let result_json = json!({
                    "success": true,
                    "matches": formatted_matches,
                    "path": path,
                    "pattern": pattern,
                    "is_regex": use_regex,
                    "match_count": matches.len(),
                    "file_exists": true
                });

                Ok(CallToolResult::success(vec![Content::text(
                    serde_json::to_string(&result_json).unwrap(),
                )]))
            }
            Err(e) => Err(Error::invalid_request(
                format!("Error searching in file {}: {}", path_buf.display(), e),
                None,
            )),
        }
    }

    /// Edit a file by replacing a text string with another
    #[tool(
        description = "Replace text in files - the old_string must match exactly once in the file. Requires write permission. Use search_in_file first to verify uniqueness. Returns error if string appears multiple times or not at all. Will only succeed if the replacement is unambiguous."
    )]
    async fn edit_file(
        &self,
        #[tool(param)]
        #[schemars(description = "Path to the file")]
        path: String,

        #[tool(param)]
        #[schemars(description = "Text to be replaced (must be unique in the file)")]
        old_string: String,

        #[tool(param)]
        #[schemars(description = "Text to replace with")]
        new_string: String,
    ) -> Result<CallToolResult, Error> {
        let path_buf = PathBuf::from(&path);

        // Check write permission for the file's directory
        let perms = self.permissions.lock().await;
        if !perms.can_write(&path_buf) {
            return Err(Error::invalid_request(
                format!("No write permission for file: {}", path_buf.display()),
                None,
            ));
        }
        drop(perms);

        // Parameter validation
        if old_string.is_empty() {
            return Err(Error::invalid_request(
                "old_string cannot be empty - nothing to replace",
                None,
            ));
        }

        // Edit the file
        match file_utils::edit_file(&path_buf, &self.permissions, &old_string, &new_string).await {
            Ok(_) => {
                let result_json = json!({
                    "success": true,
                    "path": path,
                    "old_string": old_string,
                    "new_string": new_string,
                    "replaced": true,
                    "message": format!("Successfully edited file: {}", path)
                });

                Ok(CallToolResult::success(vec![Content::text(
                    serde_json::to_string(&result_json).unwrap(),
                )]))
            }
            Err(e) => {
                // Provide more context in the error message
                if e.contains("not found in file") {
                    Err(Error::invalid_request(
                        format!(
                            "String '{}' not found in file: {}. Use search_in_file first to verify the string exists.",
                            old_string,
                            path_buf.display()
                        ),
                        None,
                    ))
                } else if e.contains("occurrences") {
                    Err(Error::invalid_request(
                        format!(
                            "Multiple occurrences of '{}' found in file: {}. Use a longer, unique string context to ensure specific replacement.",
                            old_string,
                            path_buf.display()
                        ),
                        None,
                    ))
                } else {
                    Err(Error::invalid_request(
                        format!("Error editing file {}: {}", path_buf.display(), e),
                        None,
                    ))
                }
            }
        }
    }

    /// Write content to a file
    #[tool(
        description = "Create new files or update existing ones - use append=true to add to file instead of overwriting. Creates files if they don't exist. You should read the contents of the file before writing to it to avoid data loss. Requires write permission for the directory. Returns metadata about the operation, including bytes written."
    )]
    async fn write_file(
        &self,
        #[tool(param)]
        #[schemars(description = "Path to the file")]
        path: String,

        #[tool(param)]
        #[schemars(description = "Content to write to the file")]
        content: String,

        #[tool(param)]
        #[schemars(
            description = "Whether to append to the file instead of overwriting (default: false)"
        )]
        append: Option<bool>,
    ) -> Result<CallToolResult, Error> {
        let path_buf = PathBuf::from(&path);
        let should_append = append.unwrap_or(false);

        // Check write permission for the file's directory
        let perms = self.permissions.lock().await;
        if !perms.can_write(&path_buf) {
            return Err(Error::invalid_request(
                format!("No write permission for file: {}", path_buf.display()),
                None,
            ));
        }
        drop(perms);

        // Additional parameter validation
        let file_exists = path_buf.exists();

        // Write to the file
        match file_utils::write_file(&path_buf, &self.permissions, &content, should_append).await {
            Ok(_) => {
                // Determine if this was a creation or modification
                let operation_type = if file_exists {
                    if should_append { "appended" } else { "updated" }
                } else {
                    "created"
                };

                let result_json = json!({
                    "success": true,
                    "path": path,
                    "bytes_written": content.len(),
                    "mode": if should_append { "append" } else { "overwrite" },
                    "file_existed": file_exists,
                    "operation": operation_type,
                    "message": format!("Successfully {} file: {}", operation_type, path)
                });

                Ok(CallToolResult::success(vec![Content::text(
                    serde_json::to_string(&result_json).unwrap(),
                )]))
            }
            Err(e) => {
                // Enhanced error message
                let context = if e.contains("directory does not exist") {
                    "Make sure all parent directories exist before writing. Use appropriate mkdir commands if needed."
                } else if e.contains("permission denied") {
                    "Ensure you have requested write permission for this directory."
                } else {
                    "Check the path and permissions."
                };

                Err(Error::invalid_request(
                    format!(
                        "Error writing to file {}: {}. {}",
                        path_buf.display(),
                        e,
                        context
                    ),
                    None,
                ))
            }
        }
    }

    /// Get directory tree
    #[tool(
        description = "Get a directory tree given a path. Returns a hierarchical list of directories and files with proper indentation. Skips hidden files and large directories like node_modules. Requires read permission for the directory. Use this to understand project structure and locate important files."
    )]
    async fn directory_tree(
        &self,
        #[tool(param)]
        #[schemars(description = "Path to the directory")]
        path: String,
    ) -> Result<CallToolResult, Error> {
        let path_buf = PathBuf::from(&path);

        // Check read permission for the directory
        let perms = self.permissions.lock().await;
        if !perms.can_read(&path_buf) {
            return Err(Error::invalid_request(
                format!("No read permission for directory: {}", path_buf.display()),
                None,
            ));
        }
        drop(perms);

        // Validate if path exists
        if !path_buf.exists() {
            return Err(Error::invalid_request(
                format!("Path does not exist: {}", path_buf.display()),
                None,
            ));
        }

        // Validate if path is a directory
        if !path_buf.is_dir() {
            return Err(Error::invalid_request(
                format!(
                    "Path is not a directory: {}. Specify a directory path, not a file.",
                    path_buf.display()
                ),
                None,
            ));
        }

        // Get directory tree
        match file_utils::directory_tree(&path_buf, &self.permissions).await {
            Ok(tree) => {
                // Count directory and file entries separately
                let dirs_count = tree
                    .iter()
                    .filter(|line| line.contains("/") || line.contains("\\"))
                    .count();

                let files_count = (tree.len() - 1) - dirs_count;

                let result_json = json!({
                    "success": true,
                    "tree": tree,
                    "path": path,
                    "stats": {
                        "total_entries": tree.len() - 1,  // Exclude root entry
                        "directories": dirs_count,
                        "files": files_count,
                        "skipped_entries": tree.iter()
                            .filter(|line| line.contains("[Skipped]"))
                            .count()
                    },
                    "message": format!("Successfully retrieved directory tree for: {}", path)
                });

                Ok(CallToolResult::success(vec![Content::text(
                    serde_json::to_string(&result_json).unwrap(),
                )]))
            }
            Err(e) => Err(Error::invalid_request(
                format!(
                    "Error retrieving directory tree for {}: {}",
                    path_buf.display(),
                    e
                ),
                None,
            )),
        }
    }
}
