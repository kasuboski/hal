//! Shell and execution tools for RMCP server
//!
//! This module contains tools for shell command execution and code repository
//! overview functionality using the new RMCP attribute macro pattern.

use serde_json::json;
use std::path::PathBuf;
use std::sync::Arc;
use tokio::task;

use rmcp::{
    Error,
    handler::server::tool::ToolBox,
    model::{CallToolResult, Content},
    schemars, tool,
};

use crate::mcp::code;
use crate::mcp::executor::Executor;
use crate::mcp::permissions::PermissionsRef;
use tokio::sync::Mutex;

/// Shell tool handler implementing tools for executing shell commands
/// and accessing code repository information.
#[derive(Clone)]
#[allow(dead_code)] // Fields are used indirectly by RMCP macros
pub struct ShellTools {
    /// Executor for running shell commands
    executor: Arc<dyn Executor + Send + Sync>,
    /// Permissions manager
    permissions: PermissionsRef,
    /// Project path for context
    project_path: Arc<Mutex<Option<String>>>,
}

#[tool(tool_box)]
impl ShellTools {
    /// Create a new ShellTools instance with the necessary dependencies
    pub fn new(
        executor: Arc<dyn Executor + Send + Sync>,
        permissions: PermissionsRef,
        project_path: Arc<Mutex<Option<String>>>,
    ) -> Self {
        Self {
            executor,
            permissions,
            project_path,
        }
    }

    pub fn get_tool_box() -> &'static ToolBox<Self> {
        // Calls the associated function generated by #[tool(tool_box)]
        Self::tool_box()
    }

    /// Run shell commands with permission checks
    #[tool(
        description = "Run simple shell commands - returns stdout, stderr, and exit code. Limited to safe commands. Requires execute permission first. Use request_permission with operation='execute' and path='command_name' before using this tool. Working directory must have read permission if specified."
    )]
    async fn execute_shell_command(
        &self,
        #[tool(param)]
        #[schemars(description = "Command to execute")]
        command: String,

        #[tool(param)]
        #[schemars(description = "Working directory for the command (optional)")]
        working_directory: Option<String>,
    ) -> Result<CallToolResult, Error> {
        // Parameter validation
        if command.trim().is_empty() {
            return Err(Error::invalid_request("Command cannot be empty", None));
        }

        // Extract the program name to verify permissions
        let program = command.split_whitespace().next().unwrap_or("");
        if program.is_empty() {
            return Err(Error::invalid_request("Invalid command format", None));
        }

        // Check execute permission explicitly before running
        {
            let perms = self.permissions.lock().await;
            if !perms.can_execute_command(&command) {
                return Err(Error::invalid_request(
                    format!(
                        "No execute permission for command '{}'. Use request_permission with operation='execute' and path='{}' first",
                        program, program
                    ),
                    None,
                ));
            }
        }

        // Convert working directory to PathBuf if provided and validate
        let working_dir = working_directory.as_ref().map(|wd| PathBuf::from(wd));

        // Validate working directory if provided
        if let Some(ref wd) = working_dir {
            // Check if directory exists
            if !wd.exists() {
                return Err(Error::invalid_request(
                    format!("Working directory does not exist: {}", wd.display()),
                    None,
                ));
            }

            // Check if it's actually a directory
            if !wd.is_dir() {
                return Err(Error::invalid_request(
                    format!(
                        "Specified working directory is not a directory: {}",
                        wd.display()
                    ),
                    None,
                ));
            }

            // Check read permission for working directory
            let perms = self.permissions.lock().await;
            if !perms.can_read(wd) {
                return Err(Error::invalid_request(
                    format!(
                        "No read permission for working directory: {}. Use request_permission first",
                        wd.display()
                    ),
                    None,
                ));
            }
        }

        // Execute the command using the executor
        match self
            .executor
            .execute(command.clone(), working_dir.as_deref())
            .await
        {
            Ok(result) => {
                // Structure the output consistently with other tools
                let output = json!({
                    "success": result.exit_code == 0,
                    "stdout": result.stdout,
                    "stderr": result.stderr,
                    "exit_code": result.exit_code,
                    "command": command,
                    "program": program,
                    "args": command.trim_start_matches(program).trim(),
                    "working_directory": working_directory,
                    "completed": true
                });

                Ok(CallToolResult::success(vec![Content::text(
                    serde_json::to_string(&output).unwrap(),
                )]))
            }
            Err(e) => {
                // Provide specific guidance based on error message
                let context = if e.to_string().contains("Command not in allowlist") {
                    "Request permission first using request_permission with operation='execute'"
                } else if e.to_string().contains("No such file or directory") {
                    "Ensure the command exists and is in your PATH"
                } else if e.to_string().contains("permission denied") {
                    "Check both execute permission and file system permissions"
                } else {
                    "Verify command syntax and environment"
                };

                Err(Error::invalid_request(
                    format!("Command execution failed: {}. {}", e, context),
                    None,
                ))
            }
        }
    }

    /// Get an overview of a code repository
    #[tool(
        description = "Scans and displays the content of multiple files in a directory, providing a comprehensive overview of code and other text files. Returns a JSON object with an 'overview' field containing the formatted content of each file and a 'files' count.
        This tool is ideal for:

        Initial exploration of unfamiliar codebases
        Understanding related files as a group
        Analyzing patterns across multiple files
        Getting a complete view of smaller projects

        Note: Automatically filters out binary files, large files (>10KB), and common exclusions (like node_modules). Response size is capped at 10,000 tokens. For larger directories, use directory_tree first to understand structure, then show_file for specific files of interest. Can significantly impact context window usage when querying large directories. Requires read permission for the directory."
    )]
    async fn directory_explorer(
        &self,
        #[tool(param)]
        #[schemars(description = "Path to the directory")]
        path: String,
    ) -> Result<CallToolResult, Error> {
        let path_buf = PathBuf::from(&path);

        // Check read permission for the directory
        let perms = self.permissions.lock().await;
        if !perms.can_read(&path_buf) {
            return Err(Error::invalid_request(
                format!("No read permission for directory: {}", path_buf.display()),
                None,
            ));
        }
        drop(perms);

        // Create YekConfig with tokens mode
        let mut config = yek::config::YekConfig::default();
        let ignore = yek::defaults::DEFAULT_IGNORE_PATTERNS
            .iter()
            .map(|s| s.to_string())
            .collect::<Vec<_>>();
        config.ignore_patterns = ignore;
        config.input_paths = vec![path.clone()];
        config.token_mode = true;
        config.max_size = "10K".to_string();
        config.tokens = "10000".to_string();

        config
            .validate()
            .map_err(|e| Error::invalid_request(format!("Failed to validate config: {e}"), None))?;

        // Use spawn_blocking since overview is synchronous
        let config_clone = config.clone();
        let result = task::spawn_blocking(move || code::overview(&config_clone))
            .await
            .map_err(|e| Error::invalid_request(format!("Failed to run overview: {}", e), None))?;

        match result {
            Ok((overview, files)) => {
                let result = json!({
                    "overview": overview,
                    "files": files.len(),
                    "path": path
                });

                Ok(CallToolResult::success(vec![Content::text(
                    serde_json::to_string(&result).unwrap(),
                )]))
            }
            Err(e) => Err(Error::invalid_request(
                format!("Failed to generate overview: {}", e),
                None,
            )),
        }
    }
}
